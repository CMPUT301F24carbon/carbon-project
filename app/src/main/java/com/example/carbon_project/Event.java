package com.example.carbon_project;

import android.graphics.Bitmap;
import android.net.Uri;
import android.util.Base64;

import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.journeyapps.barcodescanner.BarcodeEncoder;

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.UUID;

// The methods you should know how to use are:
// 0. Event(eventId)        Create an empty event to load from Firestore
// 0. Event(...)            Create a new event with all details
// 1. loadFromFirestore     Load event data from Firestore and update the hash map
// 2. uploadToFirestore     Upload the hash map to Firestore
// 3. lottery               Randomly selects users from the waitingList and moves them into the selectedList of Entrants
// 4. addEntrant            Adds a new entrant to the waiting list
// 5. removeEntrant         Removes an entrant from the waitingList or from the selectedList
// 6. getQRCodeUri          Return the QR code URI generated by the eventId
// 7. getPosterUri          Return the poster URI
// 8. getters and setters

// =============================================================================
// Any modification in Event class should notify me first.
// If you have any questions / requirements, please contact me @V615 on discord.
// =============================================================================

// How to create a new event:
// Event event = new Event(name, location, capacity, geolocationRequired, startDate, endDate, waitingListLimit, posterUri);

// How to create an event to load from Firestore:
// Event event = new Event(eventId);
// and then load event data

// How to load event data:
//event.loadFromFirestore(new Event.DataLoadedCallback() {
//    @Override
//    public void onDataLoaded(HashMap<String, Object> eventData) {  // You can also use the eventData HashMap to get the event details
//        // Your code here
//        callYourMethod();
//        event.uploadToFirestore();
//    }
//
//    // The following method is not mandatory
//    @Override
//    public void onError(String error) {
//        // Handle the error message if the load fails
//        // Change MainActivity to the activity that you want to display the toast message
//        Toast.makeText(MainActivity.this, error, Toast.LENGTH_SHORT).show();
//    }
//});

// How to use the QR code (Same for the poster):
//Imageview qrCodeImageView = findViewById(R.id.QR_code_image_view_here);
//qrCodeImageView.setImageURI(event.getQRCodeUri());

/**
 * Class represents an event object.
 * Stores information about event details.
 */

public class Event {
    // The event data is stored in the eventData HashMap, which includes the following keys:
    // "name", "location", "capacity", "geolocationRequired", "startDate", "endDate", "waitingListLimit", "qrCodeUri", "posterUri"
    // The following keys are used to store the entrant details:
    // "waitingList", "selectedList", "cancelledList"
    private HashMap<String, Object> eventData;
    String eventId;

    /**
     * Constructor for creating an Event with start and end dates.
     * @param eventId Unique identifier for the event.
     */
    public Event(String eventId) {
        this.eventId = eventId;
        eventData = new HashMap<>();
    }

    /**
     * Constructor for creating an Event with all details.
     * @param name Name of the event.
     * @param location Location of the event.
     * @param capacity Maximum capacity of attendees for the event.
     * @param geolocationRequired True/False depending if the organizer wants to use geolocation for this event.
     * @param startDate Start Date of the event.
     * @param endDate End Date of the event.
     * @param waitingListLimit Max size for the waitingList.
     */
    public Event(String name, String location, int capacity, boolean geolocationRequired, String startDate, String endDate, int waitingListLimit, String posterUri) {
        eventId = UUID.randomUUID().toString();

        eventData = new HashMap<>();
        eventData.put("name", name);
        eventData.put("location", location);
        eventData.put("capacity", capacity);
        eventData.put("geolocationRequired", geolocationRequired);
        eventData.put("startDate", startDate);
        eventData.put("endDate", endDate);
        eventData.put("waitingListLimit", waitingListLimit);
        eventData.put("posterUri", posterUri);
        eventData.put("qrCodeUri", generateQRCodeUri());

        eventData.put("waitingList", new ArrayList<>());
        eventData.put("selectedList", new ArrayList<>());
        eventData.put("cancelledList", new ArrayList<>());
    }

    /**
     * Callback interface for loading event data.
     */
    public interface DataLoadedCallback {
        void onDataLoaded(HashMap<String, Object> eventData);
        void onError(String error);
    }

    /**
     * Loads event data from Firestore.
     * @param callback Callback to handle the loaded data.
     */
    public void loadFromFirestore(final DataLoadedCallback callback) {
        CollectionReference eventsRef = FirebaseFirestore.getInstance().collection("events");
        DocumentReference eventRef = eventsRef.document(eventId);

        eventRef.get()
                .addOnSuccessListener(documentSnapshot -> {
                    if (documentSnapshot.exists()) {
                        // Retrieve the user data from the document
                        HashMap<String, Object> firestoreData = (HashMap<String, Object>) documentSnapshot.getData();
                        if (firestoreData != null) {
                            eventData.putAll(firestoreData);
                            System.out.println("Event " + getName() + " successfully loaded.");
                            callback.onDataLoaded(eventData);
                        }
                    } else {
                        System.out.println("Event with ID " + eventId + " does not exist.");
                        callback.onError("Event does not exist");
                    }
                })
                .addOnFailureListener(e -> {
                    System.err.println("Error loading event data: " + e.getMessage());
                    callback.onError("Failed to load event data, please check your internet connection");
                });
    }

    /**
     * Uploads the event data to Firestore.
     */
    public void uploadToFirestore() {
        CollectionReference eventsRef = FirebaseFirestore.getInstance().collection("events");
        DocumentReference eventRef = eventsRef.document(eventId);

        // Update the event data to Firestore
        eventRef.set(eventData)
                .addOnSuccessListener(aVoid -> {
                    System.out.println("Event with ID " + eventId + " successfully updated.");
                })
                .addOnFailureListener(e -> {
                    System.err.println("Error updating event: " + e.getMessage());
                });
    }

    /**
     * Randomly selects users from the waitingList and moves them into the selectedList of Entrants.
     */
    public ArrayList<String> lottery() {
        Random random = new Random();
        ArrayList<String> waitingList = (ArrayList<String>) eventData.get("waitingList");
        ArrayList<String> selectedList = (ArrayList<String>) eventData.get("selectedList");
        int capacity = (int) eventData.get("capacity");

        while (selectedList.size() < capacity && !waitingList.isEmpty()) {
            int randomIndex = random.nextInt(waitingList.size());
            selectedList.add(waitingList.remove(randomIndex));
        }

        return selectedList;
    }

    /**
     * Adds a new entrant to the waiting list.
     * @param entrantId entrant to be added to the waiting list.
     * @return true if the entrant was added to the waiting list, false otherwise.
     */
    public boolean addEntrant(String entrantId) {
        ArrayList<String> waitingList = (ArrayList<String>) eventData.get("waitingList");
        int waitingListLimit = (int) eventData.get("waitingListLimit");

        if (waitingListLimit != 0 && waitingList.size() >= waitingListLimit) {
            return false;
        } else {
            waitingList.add(entrantId);
            eventData.put("waitingList", waitingList);
            return true;
        }
    }

    /**
     * Removes an entrant from the waitingList or the selectedList instead.
     * @param entrantId entrant to be removed.
     */
    public void removeEntrant(String entrantId) {
        ArrayList<String> waitingList = (ArrayList<String>) eventData.get("waitingList");
        ArrayList<String> selectedList = (ArrayList<String>) eventData.get("selectedList");
        ArrayList<String> cancelledList = (ArrayList<String>) eventData.get("cancelledList");

        selectedList.remove(entrantId);
        waitingList.remove(entrantId);
        cancelledList.add(entrantId);
    }

    /**
     * Generates a QR code based on the eventId.
     * @return QR code image.
     */
    public String generateQRCodeUri() {
        try {
            BarcodeEncoder barcodeEncoder = new BarcodeEncoder();
            Bitmap qrCodeBitmap = barcodeEncoder.encodeBitmap(eventId, BarcodeFormat.QR_CODE, 100, 100);

            // Convert the Bitmap to a URI
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            qrCodeBitmap.compress(Bitmap.CompressFormat.PNG, 100, byteArrayOutputStream);
            byte[] byteArray = byteArrayOutputStream.toByteArray();

            // Encode Byte Array as Base64
            String base64Encoded = Base64.encodeToString(byteArray, Base64.DEFAULT);

            // Return the Base64 encoded data Uri
            return "data:image/png;base64," + base64Encoded;
        } catch (WriterException e) {
            System.err.println("Error generating QR code: " + e.getMessage());
            return null;
        }
    }

    /**
     * Returns the QR code image in Uri format.
     * @return QR code image.
     */
    public Uri getQRCodeUri() {
        String qrCodeUri = (String) eventData.get("qrCodeUri");
        return Uri.parse(qrCodeUri);
    }

    /**
     * Returns the poster image in Uri format.
     * @return poster image.
     */
    public Uri getPosterUri() {
        String posterUri = (String) eventData.get("posterUri");
        return Uri.parse(posterUri);
    }


    // Getter and Setter for eventId
    public ArrayList<String> getWaitingList() { return (ArrayList<String>) eventData.get("waitingList"); }

    public ArrayList<String> getSelectedList() { return (ArrayList<String>) eventData.get("selectedList"); }

    public ArrayList<String> getCancelledList() { return (ArrayList<String>) eventData.get("cancelledList"); }

    public String getEventId() { return eventId; }
    public void setEventId(String eventId) { this.eventId = eventId; }

    public String getName() { return (String) eventData.get("name"); }
    public void setName(String name) { eventData.put("name", name); }

    public String getLocation() { return (String) eventData.get("location"); }
    public void setLocation(String location) { eventData.put("location", location); }

    public int getCapacity() { return (int) eventData.get("capacity"); }
    public void setCapacity(int capacity) { eventData.put("capacity", capacity); }

    public boolean isGeolocationRequired() { return (boolean) eventData.get("geolocationRequired"); }
    public void setGeolocationRequired(boolean geolocationRequired) { eventData.put("geolocationRequired", geolocationRequired); }

    public int getWaitingListLimit() { return (int) eventData.get("waitingListLimit"); }
    public void setWaitingListLimit(int waitingListLimit) { eventData.put("waitingListLimit", waitingListLimit); }

    public String getStartDate() { return (String) eventData.get("startDate"); }
    public void setStartDate(String startDate) { eventData.put("startDate", startDate); }

    public String getEndDate() { return (String) eventData.get("endDate"); }
    public void setEndDate(String endDate) { eventData.put("endDate", endDate); }
}